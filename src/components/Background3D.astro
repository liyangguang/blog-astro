<div id="threejs-container"></div>
<style>
	#threejs-container {
    /* TODO: turn it on when finished. */
    display: none;
    position: fixed;
    inset: 0;
    pointer-events: none;
  }
</style>

<!-- It must use a script tag, not in the file head. So it only runs on client.
https://docs.astro.build/en/guides/troubleshooting/#document-or-window-is-not-defined -->
<script>
  import * as THREE from 'three';

  var scene, camera, renderer;
  var dotsGroup;
  var numDots = 500;
  var mouse = new THREE.Vector2();

  // Fibonacci Sphere algorithm
  function fibonacciSphere(samples) {
      var points = [];
      var phi = Math.PI * (3 - Math.sqrt(5)); // Golden angle
      for (var i = 0; i < samples; i++) {
          var y = 1 - (i / (samples - 1)) * 2; // y goes from 1 to -1
          var radius = Math.sqrt(1 - y * y); // radius at y
          var theta = phi * i; // golden angle increment
          var x = Math.cos(theta) * radius;
          var z = Math.sin(theta) * radius;
          points.push(new THREE.Vector3(x, y, z));
      }
      return points;
  }

  // Initialization function
  function init(container: HTMLElement) {
      // Scene
      scene = new THREE.Scene();

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Dots
      dotsGroup = new THREE.Group();
      var dotGeometry = new THREE.BufferGeometry();
      var dotMaterial = new THREE.PointsMaterial({ color: 0x000000, size: 0.02 });

      var positions = new Float32Array(numDots * 3);
      var points = fibonacciSphere(numDots);

      for (var i = 0; i < numDots; i++) {
          positions[i * 3] = points[i].x;
          positions[i * 3 + 1] = points[i].y;
          positions[i * 3 + 2] = points[i].z;
      }

      dotGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      var dots = new THREE.Points(dotGeometry, dotMaterial);
      dotsGroup.add(dots);
      scene.add(dotsGroup);
      window.addEventListener('mousemove', onDocumentMouseMove, false);
  }


  function onDocumentMouseMove(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth / 6) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight / 6) * 2 - 1;
  }
  function render() {
      requestAnimationFrame(render);

      // Rotate the ball based on mouse movement
      dotsGroup.rotation.y = mouse.x * Math.PI;
      dotsGroup.rotation.x = mouse.y * Math.PI * 0.5; // Limit rotation to 90 degrees in x-axis

      renderer.render(scene, camera);
  }

  // Resize function
  function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Event listeners
  window.addEventListener('resize', onWindowResize, false);

  // Initialization
  var container = document.querySelector('#threejs-container');
  init(container);
  onWindowResize(); // Adjust camera and renderer size initially
  render();
</script>
